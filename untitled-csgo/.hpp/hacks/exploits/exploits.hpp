#pragma once

namespace hacks {
	class c_exploits {
	private:
		int compute_type( ) const;

		struct cfg_t {
			bool	m_enabled{};
			int		m_dt_key{}, m_hide_shots_key{};
		};

		sdk::cfg_var_t< cfg_t > m_cfg{ 0xb19f4dcdu, {} };

		bool					m_charged{}, m_shift{},
								m_force_choke{}, m_dt_ready{};
		int						m_ticks_allowed{}, m_cur_shift_amount{},
								m_next_shift_amount{}, m_recharge_cmd{}, m_type{}, m_correction_amount{};
	public:
		void manage_wpn( valve::user_cmd_t& user_cmd );

		bool try_to_recharge( );

		int calc_correction_ticks( ) const;

		int adjust_tick_base(
			const int old_new_cmds,
			const int total_new_cmds, const int delta
		) const;

		void handle_break_lc(
			const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
			valve::bf_write_t* buffer, int& from, int& to, valve::move_msg_t* move_msg
		);

		void handle_other_shift(
			const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
			valve::bf_write_t* buffer, int& from, int& to, valve::move_msg_t* move_msg
		);

		__forceinline int& ticks_allowed( );

		__forceinline int& recharge_cmd( );

		__forceinline int& type( );

		__forceinline bool& charged( );

		__forceinline bool& shift( );

		__forceinline int& cur_shift_amount( );

		__forceinline int& next_shift_amount( );

		__forceinline int& correction_amount( );

		__forceinline bool& force_choke( );

		__forceinline bool& dt_ready( );

		__forceinline cfg_t& cfg( );
	};

	inline const auto g_exploits = std::make_unique< c_exploits >( );
}

#include "../../../.hpp/hacks/exploits/inl/exploits.inl"