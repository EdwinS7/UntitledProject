#include "../../../inc.hpp"

namespace hacks {
	void c_visuals::grenade_simulation_t::predict( const vec3_t& origin, const vec3_t& velocity, const float throw_time, const int offset ) {
		m_origin = origin;
		m_velocity = velocity;
		m_collision_group = 13;

		const auto tick = valve::to_ticks( 1.f / 30.f );

		m_last_update_tick = -tick;

		switch ( m_index ) {
		case valve::e_item_index::smoke_grenade: m_next_think_tick = valve::to_ticks( 1.5f ); break;
		case valve::e_item_index::decoy: m_next_think_tick = valve::to_ticks( 2.f ); break;
		case valve::e_item_index::flashbang:
		case valve::e_item_index::he_grenade:
			m_detonate_time = 1.5f;
			m_next_think_tick = valve::to_ticks( 0.02f );

			break;
		case valve::e_item_index::molotov:
		case valve::e_item_index::inc_grenade:
			m_detonate_time = g_ctx->cvars( ).m_molotov_throw_detonate_time->get_float( );
			m_next_think_tick = valve::to_ticks( 0.02f );

			break;
		default: break;
		}

		const auto max_sim_amt = valve::to_ticks( 60.f );
		for ( ; m_tick < max_sim_amt; ++m_tick ) {
			if ( m_next_think_tick <= m_tick )
				think( );

			if ( m_tick < offset )
				continue;

			if ( physics_simulate( ) )
				break;

			if ( ( m_last_update_tick + tick ) > m_tick )
				continue;

			update_path( false );
		}

		if ( ( m_last_update_tick + tick ) <= m_tick )
			update_path( false );

		m_expire_time = throw_time + valve::to_time( m_tick );
	}

	bool c_visuals::grenade_simulation_t::physics_simulate( ) {
		if ( m_detonated )
			return true;

		const auto new_velocity_z = m_velocity.z - ( g_ctx->cvars( ).m_sv_gravity->get_float( ) * 0.4f ) * valve::g_global_vars->m_interval_per_tick;

		auto move = m_velocity;

		move.z += new_velocity_z;
		move.z /= 2.f;

		move *= valve::g_global_vars->m_interval_per_tick;

		m_velocity.z = new_velocity_z;

		valve::trace_t trace{};

		physics_push_entity( move, trace );

		if ( m_detonated )
			return true;

		if ( trace.m_fraction != 1.f ) {
			update_path( true );

			perform_fly_collision_resolution( trace );
		}

		return false;
	}

	void c_visuals::grenade_simulation_t::physics_trace_entity(
		const vec3_t& src, const vec3_t& dst,
		const valve::e_mask mask, valve::trace_t& trace
	) {
		valve::trace_filter_skip_two_entities_t trace_filter{ m_owner, m_last_breakable, m_collision_group };

		valve::g_engine_trace->trace_ray(
			{ src, dst, { -2.f, -2.f, -2.f }, { 2.f, 2.f, 2.f } }, mask,
			reinterpret_cast< valve::trace_filter_t* >( &trace_filter ), &trace
		);

		if ( trace.m_start_solid
			&& ( trace.m_contents & valve::e_mask::contents_current_90 ) ) {
			trace.clear( );

			valve::g_engine_trace->trace_ray(
				{ src, dst, { -2.f, -2.f, -2.f }, { 2.f, 2.f, 2.f } },
				mask & ~valve::e_mask::contents_current_90,
				reinterpret_cast< valve::trace_filter_t* >( &trace_filter ), &trace
			);
		}

		if ( !trace.hit( )
			|| !trace.m_hit_entity
			|| !trace.m_hit_entity->is_player( ) )
			return;

		trace.clear( );

		valve::g_engine_trace->trace_ray(
			{ src, dst }, mask,
			reinterpret_cast< valve::trace_filter_t* >( &trace_filter ), &trace
		);
	}

	void c_visuals::grenade_simulation_t::physics_push_entity( const vec3_t& push, valve::trace_t& trace ) {
		physics_trace_entity( m_origin, m_origin + push,
			m_collision_group == 1
			? ( valve::e_mask::solid | valve::e_mask::contents_current_90 ) & ~valve::e_mask::contents_monster
			: valve::e_mask::solid | valve::e_mask::contents_opaque
			| valve::e_mask::contents_ignore_nodraw_opaque | valve::e_mask::contents_current_90 | valve::e_mask::contents_hitbox,
			trace
		);

		valve::trace_filter_skip_two_entities_t trace_filter{ m_owner, m_last_breakable, m_collision_group };

		if ( trace.m_start_solid ) {
			m_collision_group = 3;

			valve::g_engine_trace->trace_ray(
				{ m_origin - push, m_origin + push },
				( valve::e_mask::solid | valve::e_mask::contents_current_90 ) & ~valve::e_mask::contents_monster,
				reinterpret_cast< valve::trace_filter_t* >( &trace_filter ), &trace
			);
		}

		if ( trace.m_fraction != 0.f )
			m_origin = trace.m_end_pos;

		if ( !trace.m_hit_entity 
			|| trace.m_hit_entity->is_player( )
			|| ( m_index != valve::e_item_index::ta_grenade
				&& m_index != valve::e_item_index::molotov && m_index != valve::e_item_index::inc_grenade )
			|| ( m_index != valve::e_item_index::ta_grenade
				&& trace.m_plane.m_normal.z < std::cos( math::to_rad( g_ctx->cvars( ).m_weapon_molotov_maxdetonateslope->get_float( ) ) ) ) )
			return;

		detonate( true );
	}

	void c_visuals::grenade_simulation_t::perform_fly_collision_resolution( valve::trace_t& trace ) {
		auto surface_elasticity = 1.f;

		if ( trace.m_hit_entity ) {
			if ( trace.m_hit_entity->breakable( ) ) {
				m_last_breakable = trace.m_hit_entity;

				m_velocity *= 0.4f;

				return;
			}

			const auto is_player = trace.m_hit_entity->is_player( );
			if ( is_player )
				surface_elasticity = 0.3f;

			if ( trace.m_hit_entity->index( ) ) {
				if ( is_player
					&& m_last_hit_entity == trace.m_hit_entity ) {
					m_collision_group = 1;

					return;
				}

				m_last_hit_entity = trace.m_hit_entity;
			}
		}

		vec3_t velocity{};

		const auto back_off = m_velocity.dot( trace.m_plane.m_normal ) * 2.f;

		for ( std::size_t i{}; i < 3u; ++i ) {
			const auto change = trace.m_plane.m_normal[ i ] * back_off;

			velocity[ i ] = m_velocity[ i ] - change;

			if ( std::fabsf( velocity[ i ] ) >= 1.f )
				continue;

			velocity[ i ] = 0.f;
		}

		velocity *= std::clamp( surface_elasticity * 0.45f, 0.f, 0.9f );

		if ( trace.m_plane.m_normal.z > 0.7f ) {
			const auto speed_sqr = velocity.length_sqr( );
			if ( speed_sqr > 96000.f ) {
				const auto l = velocity.normalized( ).dot( trace.m_plane.m_normal );
				if ( l > 0.5f )
					velocity *= 1.f - l + 0.5f;
			}

			if ( speed_sqr < 400.f )
				m_velocity = {};
			else {
				m_velocity = velocity;

				physics_push_entity( velocity * ( ( 1.f - trace.m_fraction ) * valve::g_global_vars->m_interval_per_tick ), trace );
			}
		}
		else {
			m_velocity = velocity;

			physics_push_entity( velocity * ( ( 1.f - trace.m_fraction ) * valve::g_global_vars->m_interval_per_tick ), trace );
		}

		if ( m_bounces_count > 20 )
			return detonate( false );

		++m_bounces_count;
	}

	void c_visuals::grenade_simulation_t::think( ) {
		switch ( m_index ) {
		case valve::e_item_index::smoke_grenade:
			if ( m_velocity.length_sqr( ) <= 0.01f )
				detonate( false );

			break;
		case valve::e_item_index::decoy:
			if ( m_velocity.length_sqr( ) <= 0.04f )
				detonate( false );

			break;
		case valve::e_item_index::flashbang:
		case valve::e_item_index::he_grenade:
		case valve::e_item_index::molotov:
		case valve::e_item_index::inc_grenade:
			if ( valve::to_time( m_tick ) > m_detonate_time )
				detonate( false );

			break;
		default: break;
		}

		m_next_think_tick = m_tick + valve::to_ticks( 0.2f );
	}

	void c_visuals::grenade_simulation_t::detonate( const bool bounced ) {
		m_detonated = true;

		update_path( bounced );
	}

	void c_visuals::grenade_simulation_t::update_path( const bool bounced ) {
		m_last_update_tick = m_tick;

		m_path.emplace_back( m_origin, bounced );
	}

	bool c_visuals::add_grenade_simulation( const grenade_simulation_t& sim, const bool warning ) const {
		const auto points_count = sim.m_path.size( );
		if ( points_count < 2u
			|| valve::g_global_vars->m_cur_time >= sim.m_expire_time )
			return false;

		const auto& screen_size = ImGui::GetIO( ).DisplaySize;
		if ( warning ) {
			const auto& explode_pos = sim.m_path.back( ).first;
			auto dist = ( valve::g_local_player->origin( ) - explode_pos ).length( );

			auto prev_pos = sim.m_path.front( ).first;

			for ( auto i = 1u; i < points_count; ++i ) {
				const auto& cur_pos = sim.m_path.at( i ).first;

				add_grenade_warning_beam( prev_pos, cur_pos, m_cfg->m_other.m_grenade_trajectory_clr );

				prev_pos = cur_pos;
			}

			vec2_t screen_pos{};
			const auto on_screen = math::to_screen( explode_pos, screen_size, valve::g_engine->w2s_matrix( ), screen_pos );
			if ( !on_screen
				&& dist > 400.f )
				return true;

			const auto unk = screen_size / 18.f;
			if ( !on_screen
				|| screen_pos.x < -unk.x
				|| screen_pos.x > ( screen_size.x + unk.x )
				|| screen_pos.y < -unk.y
				|| screen_pos.y > ( screen_size.y + unk.y ) ) {
				vec3_t dir{};
				math::angle_vectors( valve::g_view_render->m_setup.m_angles, &dir );

				dir.z = 0.f;
				dir.normalize( );

				const auto radius = 210.f * ( screen_size.y / 480.f );

				auto delta = explode_pos - valve::g_view_render->m_setup.m_origin;

				delta.normalize( );

				screen_pos.x = radius * -delta.dot( vec3_t{ 0.f, 0.f, 1.f }.cross( dir ) );
				screen_pos.y = radius * -delta.dot( dir );

				const auto radians = math::to_rad(
					-math::to_deg( std::atan2( screen_pos.x, screen_pos.y ) + math::k_pi )
				);

				screen_pos.x = static_cast< int >( screen_size.x / 2.f + radius * std::sin( radians ) );
				screen_pos.y = static_cast< int >( screen_size.y / 2.f - radius * std::cos( radians ) );
			}
			
			add_filled_circle( screen_pos, 23.f, 120, ImColor(5, 5, 5) | static_cast< std::uint8_t >( 255 * ( 1.f - std::min( dist, 350.f ) / 350.f ) ) );
			
			add_circle( screen_pos, 23.f, 120, ImColor(240, 240, 240) );

			const auto mod = std::clamp(
				( sim.m_expire_time - valve::g_global_vars->m_cur_time )
				/ valve::to_time( sim.m_tick ),
				0.f, 1.f
			);

			std::vector< int > x_points{}, y_points{};

			x_points.reserve( 480 );
			y_points.reserve( 480 );

			const auto limit = math::k_pi2 * mod;
			const auto step = limit / 240;

			for ( float i{}; i < limit; i += step ) {
				x_points.emplace_back( static_cast< int >( screen_pos.x + ( 23.f * std::cos( i ) ) ) );
				y_points.emplace_back( static_cast< int >( screen_pos.y + ( 23.f * std::sin( i ) ) ) );
			}

			const auto size = x_points.size( );
			for ( auto i = 1u; i < size; ++i ) {
				x_points.emplace_back( x_points.at( size - i ) );
				y_points.emplace_back( y_points.at( size - i ) );
			}

			valve::g_surface->set_clr( ImColor(240, 240, 240) );
			valve::g_surface->add_poly_line( x_points.data( ), y_points.data( ), x_points.size( ) );

			screen_pos.y -= 7.f;

			add_text( { screen_pos.x + 1.f, screen_pos.y }, m_fonts.m_verdana26n, xorstr_( "!" ), ImColor(240, 240, 240), 3 );

			screen_pos.y += 11.f;

			constexpr auto k_meters_per_inch = 0.0254f;
			constexpr auto k_feet_per_meter = 3.281f;

			dist *= k_meters_per_inch * k_feet_per_meter;

			add_text(
				screen_pos, m_fonts.m_small_fonts8,
				std::vformat( xorstr_( "{} FT" ), std::make_format_args( static_cast< int >( dist ) ) ).data( ),
				ImColor( 240, 240, 240 ), 1
			);

			return true;
		}

		vec2_t prev_screen_pos{};
		auto prev_on_screen = math::to_screen( sim.m_path.front( ).first,
			screen_size, valve::g_engine->w2s_matrix( ), prev_screen_pos
		);

		for ( auto i = 1u; i < points_count; ++i ) {
			vec2_t cur_screen_pos{};
			const auto cur_on_screen = math::to_screen( sim.m_path.at( i ).first,
				screen_size, valve::g_engine->w2s_matrix( ), cur_screen_pos
			);

			if ( prev_on_screen
				&& cur_on_screen )
				add_line( prev_screen_pos, cur_screen_pos,
					0xb4000000u | static_cast< std::uint8_t >( m_cfg->m_other.m_grenade_trajectory_clr[ 0 ] * 255.f )
					| ( static_cast< std::uint8_t >( m_cfg->m_other.m_grenade_trajectory_clr[ 1 ] * 255.f ) << 8u )
					| ( static_cast< std::uint8_t >( m_cfg->m_other.m_grenade_trajectory_clr[ 2 ] * 255.f ) << 16u )
				);

			prev_screen_pos = cur_screen_pos;
			prev_on_screen = cur_on_screen;
		}

		return true;
	}

	bool c_visuals::calc_bbox( valve::c_player* const player, bbox_t& bbox ) const {
		auto origin = player->origin( );
		
		vec2_t bottom{};
		const auto on_screen = math::to_screen( origin, ImGui::GetIO( ).DisplaySize, valve::g_engine->w2s_matrix( ), bottom );

		origin.z += player->obb_max( ).z;

		if ( !math::to_screen( origin, ImGui::GetIO( ).DisplaySize, valve::g_engine->w2s_matrix( ), bbox.m_min ) && !on_screen )
			return false;

		bbox.m_size.y = bottom.y - bbox.m_min.y + 6;
		bbox.m_size.x = bbox.m_size.y / 2.f;

		bbox.m_min.x -= bbox.m_size.x / 2.f;

		return true;
	}

	std::optional< valve::bones_t > c_visuals::try_to_lerp_bones( const int index ) const {
		const auto& entry = g_lag_comp->entry( index - 1 );
		if ( entry.m_lag_records.size( ) < 2u )
			return std::nullopt;

		const auto max_unlag = g_ctx->cvars( ).m_sv_maxunlag->get_float( );

		const auto nci = valve::g_engine->net_channel_info( );
		const auto total_latency = std::clamp( nci->avg_latency( 0 ) + nci->avg_latency( 1 ), 0.f, max_unlag );
		const auto correct = total_latency + g_ctx->net_info( ).m_lerp;

		const auto end = entry.m_lag_records.end( );
		for ( auto it = entry.m_lag_records.begin( ); it != end; ++it ) {
			const auto current = it->get( );

			const auto latest = std::next( it ) == end;

			if ( current && current->valid( )
				&& ( !latest && ( std::next( it )->get( ) ) ) ) {
				if ( ( current->m_origin - entry.m_player->origin( ) ).length( ) < 1.f )
					continue;

				const auto next_origin = latest ? entry.m_player->origin( ) : std::next( it )->get( )->m_origin;
				const auto next_time = latest ? entry.m_player->sim_time( ) : std::next( it )->get( )->m_sim_time;

				const auto add = latest ? 1.f : ( next_time - current->m_sim_time );
				const auto delta = ( current->m_sim_time + correct + add ) - valve::g_global_vars->m_cur_time;

				const auto mult = 1.f / add;
				const auto lerp_amt = std::clamp( delta * mult, 0.f, 1.f );

				const vec3_t lerped_origin{
					std::lerp( next_origin.x, current->m_origin.x, lerp_amt ),
					std::lerp( next_origin.y, current->m_origin.y, lerp_amt ),
					std::lerp( next_origin.z, current->m_origin.z, lerp_amt )
				};

				const auto& anim_side = current->m_anim_sides.at( current->m_anim_side );

				auto lerped_bones = anim_side.m_bones;

				const auto origin_delta = lerped_origin - current->m_origin;

				for ( std::size_t i{}; i < lerped_bones.size( ); ++i ) {
					lerped_bones[ i ][ 0 ][ 3 ] += origin_delta.x;
					lerped_bones[ i ][ 1 ][ 3 ] += origin_delta.y;
					lerped_bones[ i ][ 2 ][ 3 ] += origin_delta.z;
				}

				return lerped_bones;
			}
		}

		return std::nullopt;
	}

	valve::material_t* c_visuals::create_material(
		const std::string_view name,
		const std::string_view shader, const std::string_view data
	) const {
        using init_t = void( __thiscall* )( std::uintptr_t, const char*, int, int );

        using load_from_buffer_t = void( __thiscall* )(
            std::uintptr_t, const char*, const char*, void*, const char*, void*, int
        );

        const auto key_values = reinterpret_cast< std::uintptr_t >( std::malloc( 44u ) );

        reinterpret_cast< init_t >( g_ctx->addresses( ).m_key_values_init )( key_values, shader.data( ), 0, 0 );

        reinterpret_cast< load_from_buffer_t >( g_ctx->addresses( ).m_key_values_load_from_buffer )(
            key_values, name.data( ), data.data( ), 0, 0, 0, 0
        );

        return valve::g_mat_system->create_material( name.data( ), key_values );
	}

	void c_visuals::override_material(
		const int type, const bool ignore_z,
		const float r, const float g, const float b, const float a
	) const {
		static const auto solid_mat = create_material(
			xorstr_( "untitled_solid.vmt" ),
			xorstr_( "UnlitGeneric" ),
			xorstr_(
				R"#("UnlitGeneric" {
					"$basetexture" "vgui/white"
					"$ignorez"      "0"
					"$model"		"1"
					"$flat"			"1"
					"$nocull"		"1"
					"$selfillum"	"1"
					"$halflambert"	"1"
					"$nofog"		"1"
					"$wireframe"	"0"
				})#"
			)
		);

		static const auto regular_mat = create_material(
			xorstr_( "untitled_regular.vmt" ),
			xorstr_( "VertexLitGeneric" ),
			xorstr_(
				R"#("VertexLitGeneric" {
					"$basetexture" "vgui/white"
					"$ignorez"      "0"
					"$model"		"1"
					"$flat"			"0"
					"$nocull"		"1"
					"$halflambert"	"1"
					"$nofog"		"1"
					"$wireframe"	"0"
				})#"
			)
		);

		static const auto glow_mat = create_material(
			xorstr_( "untitled_glow.vmt" ),
			xorstr_( "VertexLitGeneric" ),
			xorstr_(
				R"#("VertexLitGeneric" {
					"$additive"					"1"
					"$ignorez"					"0"
					"$envmap"					"models/effects/cube_white"
					"$envmaptint"				"[1 1 1]"
					"$envmapfresnel"			"1"
					"$envmapfresnelminmaxexp"	"[0 1 2]"
					"$alpha"					"0.8"
				})#"
			)
		);

		static const auto metallic_mat = create_material(
			xorstr_( "untitled_metallic.vmt" ),
			xorstr_( "VertexLitGeneric" ),
			xorstr_(
				R"#("VertexLitGeneric" {
					 "$basetexture"					"vgui/white"
					 "$ignorez"						"0"
					 "$envmap"						"env_cubemap"
					 "$normalmapalphaenvmapmask"	"1"
					 "$envmapcontrast"				"1"
					 "$nofog"						"1"
					 "$model"						"1"
					 "$nocull"						"0"
					 "$selfillum"					"1"
					 "$halflambert"					"1"
					 "$znearer"						"0"
					 "$flat"						"1" 
				})#"
			)
		);

		valve::material_t* material{};

		switch ( type ) {
		case 0: material = regular_mat; break;
		case 1: material = solid_mat; break;
		case 2: material = glow_mat; break;
		case 3: material = metallic_mat; break;
		}

		material->set_alpha( a );
		material->set_clr( r, g, b );
		material->set_flag( 1u << 15u, ignore_z );

		if ( const auto $envmaptint = material->find_var( xorstr_( "$envmaptint" ), nullptr, false ) )
			$envmaptint->set_vec( r, g, b );

		valve::g_studio_render->override_material( material );
	}

	void c_visuals::add_line(
		const vec2_t& from, const vec2_t& to, const std::uint32_t clr
	) const {
		valve::g_surface->set_clr( clr );
		valve::g_surface->add_line( from, to );
	}

	void c_visuals::add_rect(
		const vec2_t& pos, const vec2_t& size, const std::uint32_t clr
	) const {
		valve::g_surface->set_clr( clr );
		valve::g_surface->add_rect( pos, pos + size );
	}

	void c_visuals::add_rect_filled(
		const vec2_t& pos, const vec2_t& size, const std::uint32_t clr
	) const {
		valve::g_surface->set_clr( clr );
		valve::g_surface->add_rect_filled( pos, pos + size );
	}

	void c_visuals::add_text(
		vec2_t pos, const unsigned long font,
		const std::string_view str, const std::uint32_t clr, const int flags
	) const {
		const auto wstr = util::to_utf16( str );

		if ( flags ) {
			int width{}, height{};
			valve::g_font_mgr->calc_text_size( font, wstr.data( ), width, height );

			if ( flags & 1 )
				pos.x -= width / 2;

			if ( flags & 2 )
				pos.y -= height / 2;

			if ( flags & 4 )
				pos.x -= width;
		}

		valve::g_surface->set_text_pos( pos );
		valve::g_surface->set_text_clr( clr );
		valve::g_surface->set_text_font( font );

		valve::g_surface->add_text( wstr.data( ), wstr.size( ) );
	}

	void c_visuals::add_text(
		vec2_t pos, const unsigned long font,
		const std::wstring_view str, const std::uint32_t clr, const int flags
	) const {
		if ( flags ) {
			int width{}, height{};
			valve::g_font_mgr->calc_text_size( font, str.data( ), width, height );

			if ( flags & 1 )
				pos.x -= width / 2;

			if ( flags & 2 )
				pos.y -= height / 2;

			if ( flags & 4 )
				pos.x -= width;
		}

		valve::g_surface->set_text_pos( pos );
		valve::g_surface->set_text_clr( clr );
		valve::g_surface->set_text_font( font );

		valve::g_surface->add_text( str.data( ), str.size( ) );
	}

	void c_visuals::add_vertices(
		const valve::vertex_t* const vertices,
		const std::size_t vertices_count, const std::uint32_t clr
	) const {
		static const auto id = valve::g_surface->create_new_texture( true );
		static const std::uint8_t clr_buffer[ 4 ]{ 0xff, 0xff, 0xff, 0xff };

		valve::g_surface->set_texture_rgba( id, clr_buffer, 1, 1 );

		valve::g_surface->set_clr( clr );
		valve::g_surface->set_texture( id );

		valve::g_surface->add_textured_polygon( vertices_count, vertices );
	}

	void c_visuals::add_circle(
		const vec2_t& pos, const float radius,
		const int segments_count, const std::uint32_t clr
	) const {
		std::vector< int > x_points{}, y_points{};

		const auto step = math::k_pi2 / segments_count;
		for ( auto i = 0.f; i < math::k_pi2; i += step ) {
			x_points.emplace_back( pos.x + radius * std::cos( i ) );
			y_points.emplace_back( pos.y + radius * std::sin( i ) );
		}

		valve::g_surface->set_clr( clr );
		valve::g_surface->add_poly_line( x_points.data( ), y_points.data( ), x_points.size( ) );
	}

	void c_visuals::add_filled_circle(
		const vec2_t& pos, const float radius,
		const int segments_count, const std::uint32_t clr
	) const {
		static const auto id = valve::g_surface->create_new_texture( true );
		static const std::uint8_t clr_buffer[ 4 ]{ 0xff, 0xff, 0xff, 0xff };

		valve::g_surface->set_texture_rgba( id, clr_buffer, 1, 1 );

		valve::g_surface->set_clr( clr );
		valve::g_surface->set_texture( id );

		std::vector< valve::vertex_t > vertices{};

		const auto step = math::k_pi2 / segments_count;
		for ( auto i = 0.f; i < math::k_pi2; i += step ) {
			auto& vertex = vertices.emplace_back( );

			vertex.m_pos = { pos.x + radius * std::cos( i ), pos.y + radius * std::sin( i ) };
		}

		valve::g_surface->add_textured_polygon( vertices.size( ), vertices.data( ) );
	}

	void c_visuals::add_beam_ring( const vec3_t& pos, const float start_size, const float end_size, const float time, const float* const clr ) const {
		valve::beam_info_t info{};

		info.m_type = 7;
		info.m_center = pos;
		info.m_center.z += 5.f;

		info.m_model_index = valve::g_model_info->lookup_model_index( xorstr_( "sprites/purplelaser1.vmt" ) );
		info.m_model_name = xorstr_( "sprites/purplelaser1.vmt" );
		info.m_life = time;
		info.m_width = 7.f;
		info.m_end_width = 7.f;
		info.m_brightness = 255.f;
		info.m_speed = 1.f;
		info.m_renderable = true;
		info.m_red = clr[ 0 ] * 255.f;
		info.m_green = clr[ 1 ] * 255.f;
		info.m_blue = clr[ 2 ] * 255.f;
		info.m_segments = 1;
		info.m_speed = 150.f;
		info.m_fade_length = 1.f;

		info.m_start_radius = start_size;
		info.m_end_radius = end_size;

		const auto beam = valve::g_beams->create_beam_ring_point( info );
		if ( !beam )
			return;

		valve::g_beams->draw_beam( beam );
	}

	void c_visuals::add_beam( const vec3_t& from, const vec3_t& to, const float* const clr ) const {
		valve::beam_info_t info{};

		info.m_start = from;
		info.m_end = to;
		info.m_model_index = valve::g_model_info->lookup_model_index( xorstr_( "sprites/purplelaser1.vmt" ) );
		info.m_model_name = xorstr_( "sprites/purplelaser1.vmt" );
		info.m_life = 4.f;
		info.m_width = 6.f;
		info.m_end_width = 6.f;
		info.m_brightness = 255.f;
		info.m_speed = 0.5f;
		info.m_segments = 2;
		info.m_fade_length = 1.f;
		info.m_renderable = true;
		info.m_red = clr[ 0 ] * 255.f;
		info.m_green = clr[ 1 ] * 255.f;
		info.m_blue = clr[ 2 ] * 255.f;

		const auto beam = valve::g_beams->create_beam_points( info );
		if ( !beam )
			return;

		valve::g_beams->draw_beam( beam );
	}

	void c_visuals::add_grenade_warning_beam( const vec3_t& from, const vec3_t& to, const float* const clr ) const {
		valve::beam_info_t info{};

		info.m_start = from;
		info.m_end = to;
		info.m_model_index = valve::g_model_info->lookup_model_index( xorstr_( "sprites/white.vmt" ) );
		info.m_model_name = xorstr_( "sprites/white.vmt" );
		info.m_halo_scale = 255.f;
		info.m_life = 0.03f;
		info.m_width = 1.5f;
		info.m_end_width = 1.5f;
		info.m_brightness = 30.f;
		info.m_speed = 0.5f;
		info.m_segments = 4;
		info.m_renderable = true;
		info.m_red = clr[ 0 ] * 255.f;
		info.m_green = clr[ 1 ] * 255.f;
		info.m_blue = clr[ 2 ] * 255.f;

		const auto beam = valve::g_beams->create_beam_points( info );
		if ( !beam )
			return;

		valve::g_beams->draw_beam( beam );
	}

	void c_visuals::oof_arrow( const vec3_t& pos ) const {
		const auto& screen_size = ImGui::GetIO( ).DisplaySize;

		const auto unk = screen_size / 18.f;

		vec2_t screen_pos{};
		if ( math::to_screen( pos, screen_size, valve::g_engine->w2s_matrix( ), screen_pos )
			&& screen_pos.x >= -unk.x
			&& screen_pos.x <= ( screen_size.x + unk.x )
			&& screen_pos.y >= -unk.y
			&& screen_pos.y <= ( screen_size.y + unk.y ) )
			return;

		vec3_t dir{};
		math::angle_vectors( valve::g_view_render->m_setup.m_angles, &dir );

		dir.z = 0.f;
		dir.normalize( );

		const auto radius = ( m_cfg->m_player.m_oof_arrow_dist * 2.4f ) * ( screen_size.y / 480.f );

		auto delta = pos - valve::g_view_render->m_setup.m_origin;

		delta.normalize( );

		screen_pos.x = radius * -delta.dot( vec3_t{ 0.f, 0.f, 1.f }.cross( dir ) );
		screen_pos.y = radius * -delta.dot( dir );

		const auto radians = math::to_rad(
			-math::to_deg( std::atan2( screen_pos.x, screen_pos.y ) + math::k_pi )
		);

		const auto cos = std::cos( radians );
		const auto sin = std::sin( radians );

		screen_pos.x = static_cast< int >( screen_size.x / 2.f + radius * sin );
		screen_pos.y = static_cast< int >( screen_size.y / 2.f - radius * cos );

		std::array< valve::vertex_t, 3u > vertices{};

		vertices.at( 0u ).m_pos = screen_pos;
		vertices.at( 1u ).m_pos = { screen_pos.x + m_cfg->m_player.m_oof_arrow_size, screen_pos.y + m_cfg->m_player.m_oof_arrow_size * 2 };
		vertices.at( 2u ).m_pos = { screen_pos.x - m_cfg->m_player.m_oof_arrow_size, screen_pos.y + m_cfg->m_player.m_oof_arrow_size * 2 };

		for ( auto& vertex : vertices ) {
			const auto delta = vertex.m_pos - screen_pos;

			vertex.m_pos = {
				screen_pos.x + delta.x * cos - delta.y * sin,
				screen_pos.y + delta.x * sin + delta.y * cos
			};
		}

		add_vertices( vertices.data( ), vertices.size( ),
			0xc8000000u | static_cast< std::uint8_t >( m_cfg->m_player.m_oof_arrow_clr[ 0 ] * 255.f )
			| ( static_cast< std::uint8_t >( m_cfg->m_player.m_oof_arrow_clr[ 1 ] * 255.f ) << 8u )
			| ( static_cast< std::uint8_t >( m_cfg->m_player.m_oof_arrow_clr[ 2 ] * 255.f ) << 16u )
		);
	}

	void c_visuals::handle_player( valve::c_player* const player ) const {
		if ( !player->alive( )
			|| player == valve::g_local_player )
			return;

		const auto dormant = player->dormant( );
		if ( !dormant
			&& m_cfg->m_other.m_radar )
			player->spotted( ) = true;

		if ( ( dormant && !m_cfg->m_player.m_dormant )
			|| ( player->friendly( ) && !m_cfg->m_player.m_teammates ) )
			return;

		const auto weapon = player->weapon( );
		const auto wpn_data = weapon ? weapon->wpn_data( ) : nullptr;

		bbox_t bbox{};
		if ( !calc_bbox( player, bbox ) )
			return;

		if ( m_cfg->m_player.m_bbox ) {
			add_rect(
				{ bbox.m_min.x + 1, bbox.m_min.y + 1 },
				{ bbox.m_size.x - 2, bbox.m_size.y - 2 },
				0x96000000u
			);

			add_rect(
				bbox.m_min, bbox.m_size,
				dormant ? 0xb4828282u
				: 0xb4000000u | static_cast< std::uint8_t >( m_cfg->m_player.m_bbox_clr[ 0 ] * 255.f )
				| ( static_cast< std::uint8_t >( m_cfg->m_player.m_bbox_clr[ 1 ] * 255.f ) << 8u )
				| ( static_cast< std::uint8_t >( m_cfg->m_player.m_bbox_clr[ 2 ] * 255.f ) << 16u )
			);

			add_rect(
				{ bbox.m_min.x - 1, bbox.m_min.y - 1 },
				{ bbox.m_size.x + 2, bbox.m_size.y + 2 },
				0x96000000u
			);
		}

		if ( m_cfg->m_player.m_health_bar ) {
			add_rect_filled( { bbox.m_min.x - 6, bbox.m_min.y - 1 }, { 4, bbox.m_size.y + 2 }, 0x96000000u );

			const auto mod = std::clamp( player->health( ), 0, 100 ) / 100.f;
			const auto height = bbox.m_size.y * mod;

			add_rect_filled( { bbox.m_min.x - 5, bbox.m_min.y + bbox.m_size.y - height }, { 2, height },
				dormant ? 0xb4828282u
				: 0xb4000000u | static_cast< std::uint8_t >( 255 * ( 1.f - mod ) )
				| ( static_cast< std::uint8_t >( 255 * mod ) << 8u )
			);

			if ( player->health( ) < 100 )
				add_text( { bbox.m_min.x - 5, bbox.m_min.y + bbox.m_size.y - height - 8 },
					m_fonts.m_small_fonts8, std::to_string( player->health( ) ).data( ),
					dormant ? 0xb4828282u : 0xb4ffffffu, 1
				);
		}

		if ( m_cfg->m_player.m_name ) {
			const auto player_info = valve::g_engine->player_info( player->index( ) );
			if ( player_info.has_value( ) )
				add_text(
					{ bbox.m_min.x + bbox.m_size.x / 2.f, bbox.m_min.y - 13 },
					m_fonts.m_verdana12, player_info.value( ).m_name,
					dormant ? 0xb4828282u
					: 0xb4000000u | static_cast< std::uint8_t >( m_cfg->m_player.m_name_clr[ 0 ] * 255.f )
					| ( static_cast< std::uint8_t >( m_cfg->m_player.m_name_clr[ 1 ] * 255.f ) << 8u )
					| ( static_cast< std::uint8_t >( m_cfg->m_player.m_name_clr[ 2 ] * 255.f ) << 16u ),
					1
				);
		}

		std::size_t offset{};

		if ( m_cfg->m_player.m_ammo
			&& wpn_data
			&& wpn_data->m_type != 0
			&& wpn_data->m_type < 7
			&& wpn_data->m_max_clip1 != -1 ) {
			const auto& layer1 = player->anim_layers( ).at( 1u );
			const auto reloading = layer1.m_weight != 0.f && player->lookup_seq_act( layer1.m_sequence ) == 967;

			const auto mod = reloading
				? layer1.m_cycle : weapon->ammo( ) / static_cast< float >( wpn_data->m_max_clip1 );

			add_rect_filled( { bbox.m_min.x - 1, bbox.m_min.y + bbox.m_size.y + 2 }, { bbox.m_size.x + 2, 4 }, 0x96000000u );

			add_rect_filled( { bbox.m_min.x, bbox.m_min.y + bbox.m_size.y + 3 }, { bbox.m_size.x * mod, 2 },
				dormant ? 0xb4828282u
				: 0xb4000000u | static_cast< std::uint8_t >( m_cfg->m_player.m_ammo_clr[ 0 ] * 255.f )
				| ( static_cast< std::uint8_t >( m_cfg->m_player.m_ammo_clr[ 1 ] * 255.f ) << 8u )
				| ( static_cast< std::uint8_t >( m_cfg->m_player.m_ammo_clr[ 2 ] * 255.f ) << 16u )
			);

			if ( !reloading
				&& weapon->ammo( ) < wpn_data->m_max_clip1 )
				add_text( { bbox.m_min.x + bbox.m_size.x * mod, bbox.m_min.y + bbox.m_size.y },
					m_fonts.m_small_fonts8, std::to_string( weapon->ammo( ) ).data( ),
					dormant ? 0xb4828282u : 0xb4ffffffu, 0
				);

			offset += 4;
		}

		if ( m_cfg->m_player.m_dist ) {
			constexpr auto k_meters_per_inch = 0.0254f;
			constexpr auto k_feet_per_meter = 3.281f;

			const auto dist = static_cast< int >(
				( valve::g_local_player->origin( ) - player->origin( ) ).length( )
				* k_meters_per_inch * k_feet_per_meter
			);

			add_text(
				{ bbox.m_min.x + bbox.m_size.x / 2.f, bbox.m_min.y + bbox.m_size.y + 2 + offset },
				m_fonts.m_small_fonts8, std::vformat( xorstr_( "{} FT" ), std::make_format_args( dist ) ).data( ),
				dormant ? 0xb4828282u : 0xb4ffffffu, 1
			);

			offset += 8u;
		}

		if ( wpn_data
			&& wpn_data->m_hud_name
			&& m_cfg->m_player.m_wpn_text ) {
			auto loc_name = util::to_utf8( valve::g_localize->find_safe( wpn_data->m_hud_name ) );

			std::transform( loc_name.begin( ), loc_name.end( ), loc_name.begin( ), ::toupper );

			add_text(
				{ bbox.m_min.x + bbox.m_size.x / 2.f, bbox.m_min.y + bbox.m_size.y + 2 + offset },
				m_fonts.m_small_fonts8, loc_name.data( ),
				dormant ? 0xb4828282u
				: 0xb4000000u | static_cast< std::uint8_t >( m_cfg->m_player.m_wpn_clr[ 0 ] * 255.f )
				| ( static_cast< std::uint8_t >( m_cfg->m_player.m_wpn_clr[ 1 ] * 255.f ) << 8u )
				| ( static_cast< std::uint8_t >( m_cfg->m_player.m_wpn_clr[ 2 ] * 255.f ) << 16u ),
				1
			);

			offset += 8u;
		}

		offset = 0u;

		if ( m_cfg->m_player.m_money ) {
			add_text(
				{ bbox.m_min.x + bbox.m_size.x + 2, bbox.m_min.y },
				m_fonts.m_small_fonts8, std::vformat( xorstr_( "${}" ), std::make_format_args( player->money( ) ) ).data( ),
				dormant ? 0xb4828282u : 0xb43cc896u, 0
			);

			offset += 9;
		}

		if ( m_cfg->m_player.m_flags ) {
			const char* armor{};
			if ( player->armor_value( ) )
				armor = player->has_helmet( ) ? "HK" : "K";

			if ( armor ) {
				add_text(
					{ bbox.m_min.x + bbox.m_size.x + 2, bbox.m_min.y + offset },
					m_fonts.m_small_fonts8, armor,
					dormant ? 0xb4828282u : 0xb4ffffffu, 0
				);

				offset += 9u;
			}

			if ( player->scoped( ) ) {
				add_text(
					{ bbox.m_min.x + bbox.m_size.x + 2, bbox.m_min.y + offset },
					m_fonts.m_small_fonts8, xorstr_( "ZOOM" ),
					dormant ? 0xb4828282u : 0xb4e1b43cu, 0
				);

				offset += 9u;
			}

			if ( player->has_c4( ) ) {
				add_text(
					{ bbox.m_min.x + bbox.m_size.x + 2, bbox.m_min.y + offset },
					m_fonts.m_small_fonts8, xorstr_( "B" ),
					dormant ? 0xb4828282u : 0xb40000ffu, 0
				);

				offset += 9u;
			}
		}

		if ( dormant
			|| !m_cfg->m_player.m_skeleton )
			return;

		const auto mdl_data = player->mdl_data( );
		if ( !mdl_data
			|| !mdl_data->m_studio_hdr )
			return;

		vec2_t screen_pos{}, screen_parent_pos{};

		const auto& cached_bones = player->bone_cache( ).m_mem.m_ptr;
		const std::uint32_t skeleton_clr = 0xb4000000u
			| static_cast< std::uint8_t >( m_cfg->m_player.m_skeleton_clr[ 0 ] * 255.f )
			| ( static_cast< std::uint8_t >( m_cfg->m_player.m_skeleton_clr[ 1 ] * 255.f ) << 8u )
			| ( static_cast< std::uint8_t >( m_cfg->m_player.m_skeleton_clr[ 2 ] * 255.f ) << 16u );

		for ( std::size_t i{}; i < mdl_data->m_studio_hdr->m_bones_count; ++i ) {
			const auto bone = mdl_data->m_studio_hdr->bone( i );
			if ( !bone 
				|| !( bone->m_flags & 0x100 )
				|| bone->m_parent == -1 )
				continue;

			math::to_screen(
				{
					cached_bones[ i ][ 0 ][ 3 ],
					cached_bones[ i ][ 1 ][ 3 ],
					cached_bones[ i ][ 2 ][ 3 ]
				},
				ImGui::GetIO( ).DisplaySize,
				valve::g_engine->w2s_matrix( ),
				screen_pos
			);

			math::to_screen(
				{
					cached_bones[ bone->m_parent ][ 0 ][ 3 ],
					cached_bones[ bone->m_parent ][ 1 ][ 3 ],
					cached_bones[ bone->m_parent ][ 2 ][ 3 ]
				},
				ImGui::GetIO( ).DisplaySize,
				valve::g_engine->w2s_matrix( ),
				screen_parent_pos
			);

			add_line( screen_pos, screen_parent_pos, skeleton_clr );
		}
	}

	void c_visuals::handle_projectile( valve::c_entity* const entity, const valve::e_class_id class_id ) {
		if ( m_cfg->m_other.m_grenade_warning
			&& ( class_id == valve::e_class_id::molotov_projectile || class_id == valve::e_class_id::base_cs_grenade_projectile ) ) {
			const auto handle = entity->handle( );

			if ( entity->explode_effect_tick_begin( ) )
				m_throwed_grenades.erase( handle );
			else {
				if ( m_throwed_grenades.find( handle ) == m_throwed_grenades.end( ) ) {
					m_throwed_grenades.emplace(
						std::piecewise_construct,
						std::forward_as_tuple( handle ),
						std::forward_as_tuple(
							static_cast< valve::c_player* >( valve::g_entity_list->find_entity( entity->thrower( ) ) ),
							class_id == valve::e_class_id::molotov_projectile ? valve::e_item_index::molotov : valve::e_item_index::he_grenade,
							entity->origin( ), static_cast< valve::c_player* >( entity )->velocity( ),
							entity->grenade_spawn_time( ), valve::to_ticks( entity->sim_time( ) - entity->grenade_spawn_time( ) )
						)
					);
				}

				if ( !add_grenade_simulation( m_throwed_grenades.at( handle ), true ) )
					m_throwed_grenades.erase( handle );
			}
		}

		if ( !m_cfg->m_other.m_grenades )
			return;

		vec2_t screen_pos{};
		if ( !math::to_screen( entity->origin( ), ImGui::GetIO( ).DisplaySize, valve::g_engine->w2s_matrix( ), screen_pos ) )
			return;

		switch ( class_id ) {
		case valve::e_class_id::molotov_projectile:
			add_text(
				screen_pos, m_fonts.m_small_fonts8, xorstr_( "MOLOTOV" ),
				0xb4000000u | static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 0 ] * 255.f )
				| ( static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 1 ] * 255.f ) << 8u )
				| ( static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 2 ] * 255.f ) << 16u ),
				2
			);

			break;
		case valve::e_class_id::decoy_projectile:
			add_text(
				screen_pos, m_fonts.m_small_fonts8, xorstr_( "DECOY" ),
				0xb4000000u | static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 0 ] * 255.f )
				| ( static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 1 ] * 255.f ) << 8u )
				| ( static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 2 ] * 255.f ) << 16u ),
				2
			);

			break;
		case valve::e_class_id::base_cs_grenade_projectile:
			if ( const auto model = entity->model( ) ) {
				const std::string_view name{ model->m_name };

				if ( name.find( xorstr_( "flashbang" ) ) != std::string::npos )
					add_text(
						screen_pos, m_fonts.m_small_fonts8, xorstr_( "FLASH" ),
						0xb4000000u | static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 0 ] * 255.f )
						| ( static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 1 ] * 255.f ) << 8u )
						| ( static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 2 ] * 255.f ) << 16u ),
						2
					);
				else if ( name.find( xorstr_( "fraggrenade" ) ) != std::string::npos )
					add_text(
						screen_pos, m_fonts.m_small_fonts8, xorstr_( "FRAG" ),
						0xb4000000u | static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 0 ] * 255.f )
						| ( static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 1 ] * 255.f ) << 8u )
						| ( static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 2 ] * 255.f ) << 16u ),
						2
					);
			}

			break;
		case valve::e_class_id::inferno:
			add_text(
				screen_pos, m_fonts.m_small_fonts8, xorstr_( "FIRE" ),
				0xb4000000u | static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 0 ] * 255.f )
				| ( static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 1 ] * 255.f ) << 8u )
				| ( static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 2 ] * 255.f ) << 16u ),
				2
			);

			break;
		case valve::e_class_id::smoke_grenade_projectile:
			add_text(
				screen_pos, m_fonts.m_small_fonts8, xorstr_( "SMOKE" ),
				0xb4000000u | static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 0 ] * 255.f )
				| ( static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 1 ] * 255.f ) << 8u )
				| ( static_cast< std::uint8_t >( m_cfg->m_other.m_grenades_clr[ 2 ] * 255.f ) << 16u ),
				2
			);

			break;
		default: break;
		}
	}

	void c_visuals::handle_weapon( valve::c_weapon* const weapon ) const {
		if ( !m_cfg->m_other.m_dropped_wpns )
			return;

		const auto& origin = weapon->origin( );
		if ( origin.x == 0.f
			&& origin.y == 0.f
			&& origin.z == 0.f )
			return;

		vec2_t screen_pos{};
		if ( !math::to_screen( origin, ImGui::GetIO( ).DisplaySize, valve::g_engine->w2s_matrix( ), screen_pos ) )
			return;

		const auto wpn_data = weapon->wpn_data( );
		if ( !wpn_data )
			return;

		auto loc_name = util::to_utf8( valve::g_localize->find_safe( wpn_data->m_hud_name ) );

		std::transform( loc_name.begin( ), loc_name.end( ), loc_name.begin( ), ::toupper );

		add_text(
			screen_pos, m_fonts.m_small_fonts8, loc_name.data( ),
			0xb4000000u | static_cast< std::uint8_t >( m_cfg->m_other.m_dropped_wpns_clr[ 0 ] * 255.f )
			| ( static_cast< std::uint8_t >( m_cfg->m_other.m_dropped_wpns_clr[ 1 ] * 255.f ) << 8u )
			| ( static_cast< std::uint8_t >( m_cfg->m_other.m_dropped_wpns_clr[ 2 ] * 255.f ) << 16u ),
			2
		);
	}

	void c_visuals::init( ) {
		m_fonts.m_verdana12 = valve::g_surface->create_font( );
		valve::g_font_mgr->set_font_glyph_set( m_fonts.m_verdana12, xorstr_( "Verdana" ), 12, 700, 0, 0, 0x080u, 0x20, 0xa69f );

		m_fonts.m_verdana26 = valve::g_surface->create_font( );
		valve::g_font_mgr->set_font_glyph_set( m_fonts.m_verdana26, xorstr_( "Verdana" ), 26, 800, 0, 0, 0x080u );

		m_fonts.m_verdana26n = valve::g_surface->create_font( );
		valve::g_font_mgr->set_font_glyph_set( m_fonts.m_verdana26n, xorstr_( "Verdana" ), 26, 600, 0, 0, 0x010u );

		m_fonts.m_small_fonts8 = valve::g_surface->create_font( );
		valve::g_font_mgr->set_font_glyph_set( m_fonts.m_small_fonts8, xorstr_( "Small Fonts" ), 8, 100, 0, 0, 0x200u, 0x20, 0xa69f );
	}

	void c_visuals::on_paint( ) {
		if ( !valve::g_engine->in_game( ) )
			return;

		const auto& screen_size = ImGui::GetIO( ).DisplaySize;
		const auto screen_center = screen_size / 2.f;

		static auto last_server_tick = valve::g_client_state->m_server_tick;
		if ( !m_cfg->m_other.m_grenade_warning
			|| valve::g_client_state->m_server_tick != last_server_tick )
			m_throwed_grenades.clear( );

		last_server_tick = valve::g_client_state->m_server_tick;

		valve::c_entity* planted_bomb{};

		for ( int i{}; i <= valve::g_entity_list->highest_index( ); ++i ) {
			const auto entity = valve::g_entity_list->find_entity( i );
			if ( !entity )
				continue;

			if ( entity->is_player( ) )
				handle_player( static_cast< valve::c_player* const >( entity ) );
			else if ( const auto client_class = entity->client_class( ) ) {
				if ( entity->dormant( ) )
					continue;

				if ( entity->is_weapon( ) )
					handle_weapon( static_cast< valve::c_weapon* const >( entity ) );
				else {
					if ( client_class->m_class_id == valve::e_class_id::planted_c4 )
						planted_bomb = entity;

					handle_projectile( entity, client_class->m_class_id );
				}
			}
		}

		auto draw_hitmarker = [&] ( vec2_t pos, ImColor clr, int line_size ) {
			add_line(
					{ screen_center.x - line_size, screen_center.y - line_size },
					{ screen_center.x - ( line_size / 2 ), screen_center.y - ( line_size / 2 ) }, clr
			);
			add_line(
				{ screen_center.x - line_size, screen_center.y + line_size },
				{ screen_center.x - ( line_size / 2 ), screen_center.y + ( line_size / 2 ) }, clr
			);
			add_line(
				{ screen_center.x + line_size, screen_center.y + line_size },
				{ screen_center.x + ( line_size / 2 ), screen_center.y + ( line_size / 2 ) }, clr
			);
			add_line(
				{ screen_center.x + line_size, screen_center.y - line_size },
				{ screen_center.x + ( line_size / 2 ), screen_center.y - ( line_size / 2 ) }, clr
			);
		};

		if ( m_cfg->m_player.m_hit_marker ) {
			const auto time_delta = std::abs( valve::g_global_vars->m_cur_time - m_last_hurt_time );
			if ( time_delta <= 0.5f ) {
				const auto clr = ImColor( 240, 240, 240, static_cast< std::uint8_t >( 240 * ( 1.f - ( time_delta / 0.5f ) ) ) );

				constexpr auto k_size = 8;

				draw_hitmarker( screen_center, clr, k_size );
			}
		}

		if ( m_cfg->m_player.m_oof_arrow ) {
			for ( auto i = 1u; i <= valve::g_global_vars->m_max_clients; ++i ) {
				const auto player = static_cast< valve::c_player* >( valve::g_entity_list->find_entity( i ) );
				if ( !player
					|| player->dormant( )
					|| !player->alive( )
					|| player == valve::g_local_player
					|| ( player->friendly( ) && !m_cfg->m_player.m_teammates ) )
					continue;

				oof_arrow( player->world_space_center( ) );
			}
		}

		if ( !valve::g_local_player->alive( ) )
			return;

		if ( m_cfg->m_other.m_grenade_trajectory )
			add_grenade_simulation( m_grenade_trajectory, false );

		if ( g_movement->cfg( ).m_auto_peek_key
			&& LOWORD( GetKeyState( g_movement->cfg( ).m_auto_peek_key ) ) ) {

			const float clr[] = { 1, 0, 0.56, 1 };
			add_beam_ring( g_movement->auto_peek_start_pos( ), 26.f, 26.f, 1.f, clr );
		}

		if ( m_cfg->m_other.m_inaccuracy
			&& g_ctx->wpn_data( )
			&& g_ctx->wpn_data( )->m_type != 0
			&& g_ctx->wpn_data( )->m_type < 7 ) {
			auto radius = ( g_eng_pred->inaccuracy( ) + g_eng_pred->spread( ) ) * 320.f;

			radius /= std::tan( math::to_rad( valve::g_local_player->fov( ) ) * 0.5f ) + std::numeric_limits< float >::epsilon( );
			radius *= ImGui::GetIO( ).DisplaySize.y * ( 1.f / 480.f );

			auto pos = screen_center;

			if ( m_cfg->m_other.m_recoil ) {
				const auto d = screen_size / valve::g_local_player->fov( );

				pos.x -= d.x * valve::g_local_player->aim_punch( ).y;
				pos.y += d.y * valve::g_local_player->aim_punch( ).x;
			}

			add_filled_circle(
				pos, radius,
				std::max( 16, static_cast< int >( std::round( radius * 0.75f ) ) ),
				0xb4000000u | static_cast< std::uint8_t >( m_cfg->m_other.m_inaccuracy_clr[ 0 ] * 255.f )
				| ( static_cast< std::uint8_t >( m_cfg->m_other.m_inaccuracy_clr[ 1 ] * 255.f ) << 8u )
				| ( static_cast< std::uint8_t >( m_cfg->m_other.m_inaccuracy_clr[ 2 ] * 255.f ) << 16u )
			);
		}

		vec2_t indicator_pos{ 30.f, screen_center.y + screen_center.y / 4.f };

		if ( planted_bomb
			&& planted_bomb->is_bomb_ticking( )
			&& m_cfg->m_other.m_bomb ) {
			constexpr auto k_range = 500.f;
			constexpr auto k_radius = k_range * 3.5f;
			constexpr auto k_sigma = k_radius / 3.f;

			const auto dist = ( planted_bomb->origin( ) - valve::g_local_player->origin( ) ).length( );
			const auto fall_off = std::exp( -dist * dist / ( 2.f * k_sigma * k_sigma ) );

			auto dmg = k_range * fall_off;

			g_auto_wall->scale_dmg( valve::g_local_player, dmg, 1.f, 0.f, 0 );

			const auto hp = static_cast< float >( valve::g_local_player->health( ) );
			const auto mod = std::clamp( dmg / hp, 0.f, 1.f );

			if ( dmg >= 1.f ) {
				add_text(
					indicator_pos, m_fonts.m_verdana26,
					dmg >= hp ? xorstr_( "FATAL" ) : std::vformat( xorstr_( "-{} HP" ), std::make_format_args( static_cast< int >( dmg ) ) ).data( ),
					0x0ff0000u | static_cast< std::uint8_t >( 255.f * mod )
					| ( static_cast< std::uint8_t >( 255.f * ( 1.f - mod ) ) << 8u ),
					0
				);

				indicator_pos.y += 30.f;
			}

			add_text(
				indicator_pos, m_fonts.m_verdana26,
				std::vformat( xorstr_( "{} - {:.1f}s" ),
					std::make_format_args(
					planted_bomb->bomb_site( ) == 0 ? xorstr_( "A" ) : xorstr_( "B" ),
					planted_bomb->c4_blow( ) - valve::g_global_vars->m_cur_time
				) ).data( ), 0xb4ffffffu,
				0
			);

			indicator_pos.y -= 60.f;
		}

		if ( m_cfg->m_other.m_indicators & 7 ) {
			const auto cfg = g_aim_bot->cfg( );
			if ( cfg.m_force_safe_point_key
				&& LOWORD( GetKeyState( cfg.m_force_safe_point_key ) ) ) {
				add_text(
					indicator_pos, m_fonts.m_verdana26, xorstr_( "SP" ),
					ImColor( 240, 240, 240 ),
					0
				);

				indicator_pos.y -= 30.f;
			}
		}

		if ( m_cfg->m_other.m_indicators & 6 ) {
			const auto cfg = g_aim_bot->cfg( );
			if ( cfg.m_force_baim_key
				&& LOWORD( GetKeyState( cfg.m_force_baim_key ) ) ) {
				add_text(
					indicator_pos, m_fonts.m_verdana26, xorstr_( "BA" ),
					ImColor( 240, 240, 240 ),
					0
				);

				indicator_pos.y -= 30.f;
			}
		}


		if ( m_cfg->m_other.m_indicators & 5 ) {
			const auto cfg = g_aim_bot->cfg( );
			if ( cfg.m_min_dmg_override_key
				&& LOWORD( GetKeyState( cfg.m_min_dmg_override_key ) ) ) {
				add_text(
					indicator_pos, m_fonts.m_verdana26, xorstr_( "DMG" ),
					ImColor( 240, 240, 240 ),
					0
				);

				indicator_pos.y -= 30.f;
			}
		}

		if ( m_cfg->m_other.m_indicators & 4 ) {
			const auto cfg = g_movement->cfg( );
			if ( cfg.m_fake_duck_key
				&& LOWORD( GetKeyState( cfg.m_fake_duck_key ) ) ) {
				add_text(
					indicator_pos, m_fonts.m_verdana26, xorstr_( "DUCK" ),
					ImColor( 135, 0, 0 ),
					0
				);

				indicator_pos.y -= 30.f;
			}
		}

		if ( m_cfg->m_other.m_indicators & 3 ) {
			const auto type = g_exploits->type( );
			if ( type == 1 ) {
				add_text(
					indicator_pos, m_fonts.m_verdana26, xorstr_( "OSAA" ),
					ImColor( 240, 240, 240 ),
					0
				);

				indicator_pos.y -= 30.f;
			}
		}

		if ( m_cfg->m_other.m_indicators & 2 ) {

			const auto type = g_exploits->type( );
			if ( type == 2
				|| type == 3
				|| type == 5 ) {
				add_text(
					indicator_pos, m_fonts.m_verdana26, xorstr_( "DT" ),
					g_exploits->dt_ready( ) ? ImColor( 240, 240, 240 ) : ImColor( 135, 0, 0 ),
					0
				);

				indicator_pos.y -= 30.f;
			}
		}

		if ( m_cfg->m_other.m_indicators & 1
			&& ( g_ctx->broke_lc( ) || valve::g_local_player->velocity( ).length_2d( ) > 270.f ) ) {
			add_text(
				indicator_pos, m_fonts.m_verdana26, xorstr_( "LC" ),
				g_ctx->broke_lc( ) ? 0xb415c27bu : 0xb40000ffu,
				0
			);

			indicator_pos.y -= 30.f;
		}

		if ( m_cfg->m_other.m_spectators ) {
			std::vector< std::string > spectators{};

			for ( auto i = 1; i <= valve::g_global_vars->m_max_clients; ++i ) {
				const auto player = static_cast< valve::c_player* >( valve::g_entity_list->find_entity( i ) );
				if ( !player
					|| player == valve::g_local_player
					|| player->alive( )
					|| player->dormant( ) )
					continue;

				/* idk for some reason the handle is never equal to local handle */
				const auto target = valve::g_entity_list->find_entity( player->observer_target( ) );
				if ( !target
					|| target->index( ) != valve::g_local_player->index( ) )
					continue;

				const auto info = valve::g_engine->player_info( i );
				if ( !info.has_value( ) )
					continue;

				spectators.emplace_back( info.value( ).m_name );
			}

			std::size_t offset{};
			for ( const auto& name : spectators ) {
				add_text( { screen_size.x - 20, static_cast< float >( 10 + offset ) }, m_fonts.m_verdana12, name.data( ), 0xb4ffffffu, 4 );

				offset += 20u;
			}
		}

		if ( !m_cfg->m_other.m_penetration_reticle 
			|| !m_pen_data.has_value( ) )
			return;

		const auto center = screen_size / 2.f;

		const auto& pen = m_pen_data.value( );

		add_rect_filled( { center.x - 1.f, center.y - 1.f }, { 3.f, 3.f },
			pen.m_dmg < 1 ? pen.m_remaining_pen != 4 ? 0xb400ff00u : 0xb40000ffu : 0xb4ff0000u
		);
	}

	void c_visuals::on_render_start( ) {
		static int old_walls_transp{};
		static int old_props_transp{};

		if ( !valve::g_engine->in_game( ) ) {
			old_walls_transp = old_props_transp = -1;

			return;
		}

		auto& smoke_count = **reinterpret_cast< int** >( g_ctx->addresses( ).m_smoke_count );

		m_backup_smoke_count = smoke_count;

		if ( m_cfg->m_effects.m_remove_smoke )
			smoke_count = 0;

		**reinterpret_cast< bool** >(
			g_ctx->addresses( ).m_disable_post_processing
		) = m_cfg->m_effects.m_disable_post_processing;

		if ( m_cfg->m_player.m_sounds )
			for ( auto i = m_player_sounds.begin( ); i != m_player_sounds.end( ); i = m_player_sounds.erase( i ) )
				add_beam_ring( *i, 10.f, 440.f, 7.f, m_cfg->m_player.m_sounds_clr );
		else
			m_player_sounds.clear( );

        struct client_hit_verify_t {
            vec3_t	m_pos{};
            float	m_time{};
            float	m_expires{};
        };

        static int last_count{};

        /* FF 71 0C F3 0F 11 84 24 ? ? ? ? F3 0F 10 84 24 ? ? ? ? */
        const auto& client_impacts_list = *reinterpret_cast< valve::utl_vec_t< client_hit_verify_t >* >(
            reinterpret_cast< std::uintptr_t >( valve::g_local_player.operator valve::c_player * ( ) ) + 0x11C50u
        );

		if ( m_cfg->m_effects.m_bullet_impacts )
			for ( auto i = client_impacts_list.m_size; i > last_count; --i )
				valve::g_debug_overlay->add_box_overlay( client_impacts_list.at( i - 1 ).m_pos, { -1.f, -1.f, -1.f }, { 1.f, 1.f, 1.f }, {}, 255, 0, 0, 127, 4.f );

        last_count = client_impacts_list.m_size;

		if ( m_cfg->m_effects.m_bullet_tracers
			|| m_cfg->m_effects.m_bullet_impacts )
			for ( auto i = m_bullet_impacts.begin( ); i != m_bullet_impacts.end( ); i = m_bullet_impacts.erase( i ) ) {
				if ( m_cfg->m_effects.m_bullet_impacts )
					valve::g_debug_overlay->add_box_overlay( i->m_pos, { -1.f, -1.f, -1.f }, { 1.f, 1.f, 1.f }, {}, 0, 0, 255, 127, 4.f );

				if ( i->m_final
					&& m_cfg->m_effects.m_bullet_tracers )
					add_beam( i->m_from, i->m_pos, m_cfg->m_effects.m_bullet_tracers_clr );
			}
		else 
			m_bullet_impacts.clear( );

		static const std::array< valve::material_t*, 4u > smoke_materials{
			valve::g_mat_system->find_material( xorstr_( "particle/vistasmokev1/vistasmokev1_fire" ), nullptr ),
			valve::g_mat_system->find_material( xorstr_( "particle/vistasmokev1/vistasmokev1_smokegrenade" ), nullptr ),
			valve::g_mat_system->find_material( xorstr_( "particle/vistasmokev1/vistasmokev1_emods" ), nullptr ),
			valve::g_mat_system->find_material( xorstr_( "particle/vistasmokev1/vistasmokev1_emods_impactdust" ), nullptr )
		};

		static const std::array< valve::material_t*, 2u > flash_materials{
			valve::g_mat_system->find_material( xorstr_( "effects/flashbang" ), nullptr ),
			valve::g_mat_system->find_material( xorstr_( "effects/flashbang_white" ), nullptr )
		};

		for ( auto& material : smoke_materials )
			if ( material )
				material->set_flag( 4, m_cfg->m_effects.m_remove_smoke );

		for ( auto& material : flash_materials )
			if ( material )
				material->set_flag( 4, m_cfg->m_effects.m_remove_flash );

		if ( old_walls_transp == m_cfg->m_effects.m_transparent_walls
			&& old_props_transp == m_cfg->m_effects.m_transparent_props )
			return;

		const auto invalid = valve::g_mat_system->invalid_material( );
		for ( auto i = valve::g_mat_system->first_material( ); i != invalid; i = valve::g_mat_system->next_material( i ) ) {
			const auto mat = valve::g_mat_system->material( i );
			if ( !mat )
				continue;

			const auto texture_group_name = mat->texture_group( );

			if ( *reinterpret_cast< const std::uint32_t* >( texture_group_name + 3u ) == 't dl' )
				mat->set_alpha( m_cfg->m_effects.m_transparent_walls / 100.f );
			else if ( *reinterpret_cast< const std::uint32_t* >( texture_group_name + 8u ) == 't po' )
				mat->set_alpha( m_cfg->m_effects.m_transparent_props / 100.f );
		}

		old_walls_transp = m_cfg->m_effects.m_transparent_walls;
		old_props_transp = m_cfg->m_effects.m_transparent_props;
	}

	void c_visuals::on_render_end( ) {
		if ( !valve::g_engine->in_game( ) )
			return;

		if ( m_cfg->m_effects.m_remove_smoke )
			**reinterpret_cast< int** >( g_ctx->addresses( ).m_smoke_count ) = m_backup_smoke_count;
	}

	void c_visuals::on_create_move( const valve::user_cmd_t& cmd ) {
		m_grenade_trajectory = {};
		m_pen_data = std::nullopt;

		if ( !g_ctx->weapon( )
			|| !g_ctx->wpn_data( ) )
			return;

		qangle_t dir{};

		if ( m_cfg->m_other.m_penetration_reticle
			&& g_ctx->wpn_data( )->m_type != 0
			&& g_ctx->wpn_data( )->m_type < 7 ) {
			math::angle_vectors( cmd.m_view_angles, &dir );

			m_pen_data = g_auto_wall->fire_bullet(
				valve::g_local_player, nullptr, g_ctx->wpn_data( ),
				g_ctx->weapon( )->item_index( ) == valve::e_item_index::taser,
				g_ctx->shoot_pos( ), g_ctx->shoot_pos( ) + dir * g_ctx->wpn_data( )->m_range
			);
		}

		if ( !m_cfg->m_other.m_grenade_trajectory
			|| g_ctx->wpn_data( )->m_type != 9
			|| ( !g_ctx->weapon( )->pin_pulled( ) && g_ctx->weapon( )->throw_time( ) == 0.f ) )
			return;

		m_grenade_trajectory.m_owner = valve::g_local_player;
		m_grenade_trajectory.m_index = g_ctx->weapon( )->item_index( );

		auto view_angles = cmd.m_view_angles;

		if ( view_angles.x < -90.f )
			view_angles.x += 360.f;
		else if ( view_angles.x > 90.f )
			view_angles.x -= 360.f;

		view_angles.x -= ( 90.f - std::fabsf( view_angles.x ) ) * 10.f / 90.f;

		math::angle_vectors( view_angles, &dir );

		const auto throw_strength = std::clamp( g_ctx->weapon( )->throw_strength( ), 0.f, 1.f );

		auto src = g_ctx->shoot_pos( );

		src.z += throw_strength * 12.f - 12.f;

		valve::trace_t trace{};
		valve::trace_filter_simple_t trace_filter{ valve::g_local_player, 0 };

		valve::g_engine_trace->trace_ray(
			{ src, src + dir * 22.f, { -2.f, -2.f, -2.f }, { 2.f, 2.f, 2.f } },
			valve::e_mask::solid | valve::e_mask::contents_current_90,
			reinterpret_cast< valve::trace_filter_t* >( &trace_filter ), &trace
		);

		const auto velocity = std::clamp(
			g_ctx->wpn_data( )->m_throw_velocity * 0.9f, 15.f, 750.f
		) * ( throw_strength * 0.7f + 0.3f );

		m_grenade_trajectory.predict( 
			trace.m_end_pos - dir * 6.f,
			dir * velocity + valve::g_local_player->velocity( ) * 1.25f,
			valve::g_global_vars->m_cur_time, 0
		);
	}

	void c_visuals::on_override_view( valve::view_setup_t* const setup ) {
		static bool keep_height{};

		if ( !valve::g_engine->in_game( ) ) {
			keep_height = false;

			return;
		}

		if ( m_cfg->m_effects.m_fov_changer ) {
			setup->m_fov = 90.f + m_cfg->m_effects.m_fov;

			if ( m_cfg->m_effects.m_viewmodel_fov_changer )
				setup->m_view_model_fov = ( 60.f - m_cfg->m_effects.m_fov ) + m_cfg->m_effects.m_viewmodel_fov;
		}
		else if ( m_cfg->m_effects.m_viewmodel_fov_changer )
			setup->m_view_model_fov = 60.f + m_cfg->m_effects.m_viewmodel_fov;

		if ( valve::g_local_player->alive( ) ) {
			if ( g_movement->should_fake_duck( ) ) {
				keep_height = true;

				setup->m_origin.z = valve::g_local_player->get_abs_origin( ).z + 64.0625f;
			}
			else if ( keep_height ) {
				const auto& local_data = g_eng_pred->local_data( ).at( g_ctx->last_cmd_number( ) % 150 );
				if ( local_data.m_net_vars.m_duck_amount != local_data.m_pred_net_vars.m_duck_amount ) {
					if ( local_data.m_pred_net_vars.m_duck_amount > 0.05f )
						setup->m_origin.z = valve::g_local_player->get_abs_origin( ).z + 64.0625f;
					else
						keep_height = false;
				}
				else
					keep_height = false;
			}

			float distance = m_cfg->m_effects.m_thirdperson_distance;

			vec3_t angles = valve::g_engine->view_angles( );
			vec3_t inverse_angles = valve::g_engine->view_angles( );
			inverse_angles.z = ( distance + 32.f );

			vec3_t forward, right, up;
			math::angle_vectors( inverse_angles, &forward, &right, &up );

			valve::trace_t trace;
			valve::trace_filter_simple_t trace_filter{ valve::g_local_player, 0 };

			auto eye_pos = valve::g_local_player->get_abs_origin( ) + valve::g_local_player->view_offset( );
			auto offset = eye_pos + forward * -( distance + 32.f ) + right + up;

			valve::ray_t ray( eye_pos, offset );
			valve::g_engine_trace->trace_ray( ray, valve::e_mask::shot_hull, reinterpret_cast< valve::trace_filter_t* >( &trace_filter ), &trace );

			angles.z = distance * trace.m_fraction;

			valve::g_input->m_camera_in_third_person = m_cfg->m_effects.m_force_thirdperson_alive
				&& m_cfg->m_effects.m_force_thirdperson_key && LOWORD( GetKeyState( m_cfg->m_effects.m_force_thirdperson_key ) );

			valve::g_input->m_camera_offset = angles;
		}
		else {
			keep_height = false;

			if ( m_cfg->m_effects.m_force_thirdperson_dead
				&& valve::g_local_player->observer_mode( ) == 4 ) {
				valve::g_local_player->observer_mode( ) = 5;

				valve::g_input->m_camera_in_third_person = false;
			}
		}
	}

	void c_visuals::on_post_screen_effects( ) {
		if ( !valve::g_engine->in_game( ) )
			return m_shot_mdls.clear( );

		if ( m_cfg->m_other.m_bomb ) {
			for ( int i{}; i < valve::g_glow_mgr->m_objects.m_size; ++i ) {
				auto& object = valve::g_glow_mgr->m_objects.at( i );
				if ( !object.m_entity
					|| object.m_next_free_slot != -2 )
					continue;

				const auto client_class = object.m_entity->client_class( );
				if ( !client_class
					|| client_class->m_class_id != valve::e_class_id::planted_c4 )
					continue;

				object.m_render_when_occluded = true;
				object.m_render_when_unoccluded = false;
				object.m_red = m_cfg->m_other.m_bomb_clr[ 0 ];
				object.m_green = m_cfg->m_other.m_bomb_clr[ 1 ];
				object.m_blue = m_cfg->m_other.m_bomb_clr[ 2 ];
				object.m_alpha = m_cfg->m_other.m_bomb_clr[ 3 ];
			}
		}

		if ( !m_cfg->m_clred_mdls.m_on_shot
			|| m_shot_mdls.empty( ) )
			return;

		const auto context = valve::g_mat_system->render_context( );
		if ( !context )
			return;

		m_rendering_shot_mdl = true;

		for ( auto i = m_shot_mdls.begin( ); i != m_shot_mdls.end( ); ) {
			const auto delta = ( i->m_time + m_cfg->m_clred_mdls.m_on_shot_mdl_time ) - valve::g_global_vars->m_real_time;
			if ( delta <= 0.f ) {
				i = m_shot_mdls.erase( i );

				continue;
			}

			override_material(
				m_cfg->m_clred_mdls.m_on_shot_mdl_type, true,
				m_cfg->m_clred_mdls.m_on_shot_clr[ 0 ],
				m_cfg->m_clred_mdls.m_on_shot_clr[ 1 ],
				m_cfg->m_clred_mdls.m_on_shot_clr[ 2 ],
				m_cfg->m_clred_mdls.m_on_shot_clr[ 3 ] * ( delta / m_cfg->m_clred_mdls.m_on_shot_mdl_time )
			);

			valve::g_model_render->draw_model( context, i->m_state, i->m_info, i->m_bones.data( ) );

			valve::g_studio_render->override_material( nullptr );

			i = std::next( i );
		}

		m_rendering_shot_mdl = false;
	}

	bool c_visuals::on_draw_model(
		valve::studio_render_t* const ecx, const std::uintptr_t edx,
		const std::uintptr_t a0, const valve::draw_model_info_t& info,
		mat3x4_t* const bones, float* const a3, float* const a4, const vec3_t& origin, int flags
	) const {
		if ( !valve::g_local_player
			|| !valve::g_engine->in_game( )
			|| ecx->forced_material_override( )
			|| !info.m_renderable || !info.m_studio_hdr )
			return true;

		if ( m_rendering_shot_mdl )
			return true;

		const auto entity = reinterpret_cast< valve::c_entity* const >( info.m_renderable - 0x4 );
		if ( !entity )
			return true;
		
		const auto client_class = entity->client_class( );
		if ( !client_class )
			return true;

		const auto move_parent = valve::g_entity_list->find_entity( entity->move_parent( ) );
		const auto move_parent_player = move_parent && move_parent->index( ) >= 1 && move_parent->index( ) <= 64;
		const auto player_mdl = *reinterpret_cast< const std::uint32_t* >( info.m_studio_hdr->m_name + 14u ) == 'yalp';

		if ( m_cfg->m_effects.m_disable_rendering_of_teammates
			&& ( ( player_mdl && entity->friendly( ) && entity != valve::g_local_player )
				|| ( move_parent_player && move_parent->friendly( ) && move_parent != valve::g_local_player ) ) )
			return false;

		if ( m_cfg->m_effects.m_disable_rendering_of_ragdolls
			&& client_class->m_class_id == valve::e_class_id::ragdoll )
			return false;

		if ( player_mdl ) {
			if ( !m_cfg->m_clred_mdls.m_ragdoll
				&& client_class->m_class_id == valve::e_class_id::ragdoll )
				return true;

			const auto friendly = entity->friendly( );
			const auto local_player = entity == valve::g_local_player;

			if ( !friendly ) {
				if ( entity->is_player( )
					&& m_cfg->m_clred_mdls.m_shadow ) {
					auto lerped_bones = try_to_lerp_bones( entity->index( ) );
					if ( lerped_bones.has_value( ) ) {
						override_material(
							m_cfg->m_clred_mdls.m_shadow_mdl_type, true,
							m_cfg->m_clred_mdls.m_shadow_clr[ 0 ],
							m_cfg->m_clred_mdls.m_shadow_clr[ 1 ],
							m_cfg->m_clred_mdls.m_shadow_clr[ 2 ],
							m_cfg->m_clred_mdls.m_shadow_clr[ 3 ]
						);

						hooks::orig_draw_model(
							ecx, edx, a0, info,
							lerped_bones.value( ).data( ), a3, a4, origin, flags
						);

						valve::g_studio_render->override_material( nullptr );
					}
				}

				if ( m_cfg->m_clred_mdls.m_player_behind_wall ) {
					override_material(
						m_cfg->m_clred_mdls.m_player_mdl_type, true,
						m_cfg->m_clred_mdls.m_player_behind_wall_clr[ 0 ],
						m_cfg->m_clred_mdls.m_player_behind_wall_clr[ 1 ],
						m_cfg->m_clred_mdls.m_player_behind_wall_clr[ 2 ],
						m_cfg->m_clred_mdls.m_player_behind_wall_clr[ 3 ]
					);

					hooks::orig_draw_model(
						ecx, edx, a0, info, bones, a3, a4, origin, flags
					);

					valve::g_studio_render->override_material( nullptr );
				}

				if ( m_cfg->m_clred_mdls.m_player ) {
					override_material(
						m_cfg->m_clred_mdls.m_player_mdl_type, false,
						m_cfg->m_clred_mdls.m_player_clr[ 0 ],
						m_cfg->m_clred_mdls.m_player_clr[ 1 ],
						m_cfg->m_clred_mdls.m_player_clr[ 2 ],
						m_cfg->m_clred_mdls.m_player_clr[ 3 ]
					);

					hooks::orig_draw_model(
						ecx, edx, a0, info, bones, a3, a4, origin, flags
					);

					valve::g_studio_render->override_material( nullptr );

					return false;
				}
			}
			else if ( friendly && !local_player ) {
				if ( m_cfg->m_clred_mdls.m_teammate_behind_wall ) {
					override_material(
						m_cfg->m_clred_mdls.m_teammate_mdl_type, true,
						m_cfg->m_clred_mdls.m_teammate_behind_wall_clr[ 0 ],
						m_cfg->m_clred_mdls.m_teammate_behind_wall_clr[ 1 ],
						m_cfg->m_clred_mdls.m_teammate_behind_wall_clr[ 2 ],
						m_cfg->m_clred_mdls.m_teammate_behind_wall_clr[ 3 ]
					);

					hooks::orig_draw_model(
						ecx, edx, a0, info, bones, a3, a4, origin, flags
					);

					valve::g_studio_render->override_material( nullptr );
				}

				if ( m_cfg->m_clred_mdls.m_teammate ) {
					override_material(
						m_cfg->m_clred_mdls.m_teammate_mdl_type, false,
						m_cfg->m_clred_mdls.m_teammate_clr[ 0 ],
						m_cfg->m_clred_mdls.m_teammate_clr[ 1 ],
						m_cfg->m_clred_mdls.m_teammate_clr[ 2 ],
						m_cfg->m_clred_mdls.m_teammate_clr[ 3 ]
					);

					hooks::orig_draw_model(
						ecx, edx, a0, info, bones, a3, a4, origin, flags
					);

					valve::g_studio_render->override_material( nullptr );

					return false;
				}
			}
			else if ( local_player ) {
				if ( m_cfg->m_clred_mdls.m_local_player_fake ) {
					override_material(
						m_cfg->m_clred_mdls.m_local_player_fake_mdl_type, false,
						m_cfg->m_clred_mdls.m_local_player_fake_clr[ 0 ],
						m_cfg->m_clred_mdls.m_local_player_fake_clr[ 1 ],
						m_cfg->m_clred_mdls.m_local_player_fake_clr[ 2 ],
						m_cfg->m_clred_mdls.m_local_player_fake_clr[ 3 ]
					);

					hooks::orig_draw_model(
						ecx, edx, a0, info,
						g_anim_sync->local_data( ).m_fake.m_bones.data( ),
						a3, a4, origin, flags
					);

					valve::g_studio_render->override_material( nullptr );
				}

				if ( m_cfg->m_clred_mdls.m_local_player ) {
					override_material(
						m_cfg->m_clred_mdls.m_local_player_mdl_type, false,
						m_cfg->m_clred_mdls.m_local_player_clr[ 0 ],
						m_cfg->m_clred_mdls.m_local_player_clr[ 1 ],
						m_cfg->m_clred_mdls.m_local_player_clr[ 2 ],
						m_cfg->m_clred_mdls.m_local_player_clr[ 3 ]
					);

					hooks::orig_draw_model(
						ecx, edx, a0, info, bones, a3, a4, origin, flags
					);

					valve::g_studio_render->override_material( nullptr );

					return false;
				}
			}
		}
		else if ( *reinterpret_cast< const std::uint32_t* >( info.m_studio_hdr->m_name + 17u ) == 'smra' ) {
			if ( m_cfg->m_clred_mdls.m_hands ) {
				override_material(
					m_cfg->m_clred_mdls.m_hands_mdl_type, false,
					m_cfg->m_clred_mdls.m_hands_clr[ 0 ],
					m_cfg->m_clred_mdls.m_hands_clr[ 1 ],
					m_cfg->m_clred_mdls.m_hands_clr[ 2 ],
					m_cfg->m_clred_mdls.m_hands_clr[ 3 ]
				);

				hooks::orig_draw_model(
					ecx, edx, a0, info, bones, a3, a4, origin, flags
				);

				valve::g_studio_render->override_material( nullptr );

				return false;
			}
		}
		else if ( *reinterpret_cast< const std::uint32_t* >( info.m_studio_hdr->m_name ) == 'paew'
			&& info.m_studio_hdr->m_name[ 8 ] == 'v' ) {
			if ( m_cfg->m_clred_mdls.m_wpn_view_model ) {
				override_material(
					m_cfg->m_clred_mdls.m_wpn_view_model_mdl_type, false,
					m_cfg->m_clred_mdls.m_wpn_view_model_clr[ 0 ],
					m_cfg->m_clred_mdls.m_wpn_view_model_clr[ 1 ],
					m_cfg->m_clred_mdls.m_wpn_view_model_clr[ 2 ],
					m_cfg->m_clred_mdls.m_wpn_view_model_clr[ 3 ]
				);

				hooks::orig_draw_model(
					ecx, edx, a0, info, bones, a3, a4, origin, flags
				);

				valve::g_studio_render->override_material( nullptr );

				return false;
			}
		}
		else if ( move_parent_player ) {
			if ( m_cfg->m_clred_mdls.m_weapons ) {
				override_material(
					m_cfg->m_clred_mdls.m_weapons_mdl_type, false,
					m_cfg->m_clred_mdls.m_weapons_clr[ 0 ],
					m_cfg->m_clred_mdls.m_weapons_clr[ 1 ],
					m_cfg->m_clred_mdls.m_weapons_clr[ 2 ],
					m_cfg->m_clred_mdls.m_weapons_clr[ 3 ]
				);

				hooks::orig_draw_model(
					ecx, edx, a0, info, bones, a3, a4, origin, flags
				);

				valve::g_studio_render->override_material( nullptr );

				return false;
			}
		}

		return true;
	}

	void c_visuals::on_calc_view(
		valve::c_player* const ecx, const std::uintptr_t edx,
		vec3_t& origin, qangle_t& angles, float& z_near, float& z_far, float& fov
	) {
		const auto backup_aim_punch = valve::g_local_player->aim_punch( );
		const auto backup_view_punch = valve::g_local_player->view_punch( );
		const auto backup_use_new_anim_state = valve::g_local_player->use_new_anim_state( );

		valve::g_local_player->use_new_anim_state( ) = false;

		if ( m_cfg->m_effects.m_recoil_adjustment ) {
			switch ( m_cfg->m_effects.m_recoil_adjustment ) {
			case 1:
				valve::g_local_player->view_punch( ) = {};
				break;
			case 2:
				valve::g_local_player->aim_punch( )
					= valve::g_local_player->view_punch( ) = {};
				break;
			}
		}

		hooks::orig_calc_view( ecx, edx, origin, angles, z_near, z_far, fov );

		valve::g_local_player->use_new_anim_state( ) = backup_use_new_anim_state;

		valve::g_local_player->aim_punch( ) = backup_aim_punch;
		valve::g_local_player->view_punch( ) = backup_view_punch;
	}

	void c_visuals::add_shot_mdl( valve::c_player* const player, const std::shared_ptr< lag_record_t >& lag_record ) {
		const auto model = player->model( );
		if ( !model )
			return;

		const auto mdl_data = player->mdl_data( );
		if ( !mdl_data
			|| !mdl_data->m_studio_hdr )
			return;

		auto& shot_mdl = m_shot_mdls.emplace_back( );

		shot_mdl.m_time = valve::g_global_vars->m_real_time;
		shot_mdl.m_state.m_studio_hdr = mdl_data->m_studio_hdr;
		shot_mdl.m_state.m_studio_hw_data = valve::g_mdl_cache->lookup_hw_data( model->m_studio );
		shot_mdl.m_state.m_renderable = player->renderable( );

		const auto& anim_side = lag_record->m_anim_sides.at( lag_record->m_anim_side );

		shot_mdl.m_info.m_renderable = player->renderable( );
		shot_mdl.m_info.m_model = model;
		shot_mdl.m_info.m_hitbox_set = player->hitbox_set_index( );
		shot_mdl.m_info.m_skin = player->skin( );
		shot_mdl.m_info.m_body = player->body( );
		shot_mdl.m_info.m_index = player->index( );
		shot_mdl.m_info.m_origin = lag_record->m_origin;
		shot_mdl.m_info.m_angles.y = anim_side.m_foot_yaw;

		shot_mdl.m_info.m_instance = player->model_instance( );
		shot_mdl.m_info.m_flags = 1;

		std::memcpy(
			shot_mdl.m_bones.data( ), anim_side.m_bones.data( ),
			anim_side.m_bones_count * sizeof( mat3x4_t )
		);

		g_ctx->addresses( ).m_angle_matrix( shot_mdl.m_info.m_angles, shot_mdl.m_world_matrix );

		shot_mdl.m_world_matrix[ 0 ][ 3 ] = lag_record->m_origin.x;
		shot_mdl.m_world_matrix[ 1 ][ 3 ] = lag_record->m_origin.y;
		shot_mdl.m_world_matrix[ 2 ][ 3 ] = lag_record->m_origin.z;

		shot_mdl.m_info.m_model_to_world = shot_mdl.m_state.m_model_to_world = &shot_mdl.m_world_matrix;
	}
}